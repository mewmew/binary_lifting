% related work, state of the art.

% === [ Disassembly ] ==========================================================

\section{Disassembly}

% --- [ Linear Sweep Disassembly ] ---------------------------------------------

\subsection{Linear Sweep Disassembly}

\todo{foo}

% --- [ Recursive Descent Disassembly ] ----------------------------------------

\subsection{Recursive Descent Disassembly}

\todo{foo}

% --- [ Shingled Graph Disassembly ] -------------------------------------------

\subsection{Shingled Graph Disassembly}

\todo{foo}

\cite{singled_graph_disassembly}, \cite{superset_disassembly}

% --- [ Separating Code from Data ] --------------------------------------------

\subsection{Separating Code from Data}

e.g. jump tables

% TODO: add note about undecidability of separating code from data.
% ref: 2019 retrowrite, binary insyrumentation
% > In general, deciding whether bytes represent code or data is undecidable [30] (R. Wartell, Y. Zhou, K. W. Hamlen, M. Kantarcioglu, and B. Thuraisingham, “Differentiating code from data in x86 binaries,” in Joint European Conference on Machine Learning and Knowledge Discovery in Databases. Springer, 2011, pp. 522–536.).
% >
% > However, as pointed out by Andriesse et al. [31], the undecidablilty is driven by corner cases and disassembling executables generated by mainstream compilers, e.g., gcc, clang, and Visual Studio, is possible with high accuracy (nearly 100%), even when compiled with high optimization.


% --- [ Discontinuous Functions ] ----------------------------------------------

\subsection{Discontinuous Functions}

e.g. basic blocks shared and re-used in-between functions.

% Identifying function boundaries:
%
% ref: https://blog.formallyapplied.com/2020/05/function-identification/
% ref: (paper) 2020, Efficient Binary-Level Coverage Analysis, https://arxiv.org/abs/2004.14191
%
% Another ref is rev.ng.
